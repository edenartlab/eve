"""Handler for moderator start_session tool.

This tool initializes the multi-agent session by creating agent workspaces
with personalized contexts generated by the moderator.
"""

from typing import Any, Dict, List

from bson import ObjectId
from loguru import logger
from pydantic import BaseModel

from eve.agent import Agent
from eve.agent.session.models import (
    ChatMessage,
    EdenMessageData,
    EdenMessageType,
    Session,
)
from eve.tool import ToolContext


class AgentContext(BaseModel):
    """Per-agent context from moderator."""

    agent_username: str
    context: str


class ModeratorInitResponse(BaseModel):
    """Simulates ConductorInitResponse for agent session creation."""

    shared_understanding: str
    agent_contexts: List[AgentContext]
    finish_criteria: str


async def handler(context: ToolContext) -> Dict[str, Any]:
    """Initialize the multi-agent session.

    Creates agent_sessions with personalized contexts for each agent.

    Args:
        context: ToolContext containing:
            - args.shared_understanding: Common knowledge all agents share
            - args.agent_contexts: List of {agent_username, context} objects
            - args.finish_criteria: When session should end
            - session: The moderator_session ID (which has a parent_session)

    Returns:
        Dict with status and created agent sessions

    Raises:
        Exception: If validation fails or required data is missing
    """
    if not context.session:
        raise Exception("Session is required")

    # Get the moderator session
    moderator_session = Session.from_mongo(context.session)
    if not moderator_session:
        raise Exception(f"Moderator session {context.session} not found")

    if not moderator_session.parent_session:
        raise Exception(
            "This tool can only be used from a moderator_session with a parent. "
            "The current session has no parent_session."
        )

    # Get the parent session
    parent_session = Session.from_mongo(moderator_session.parent_session)
    if not parent_session:
        raise Exception(f"Parent session {moderator_session.parent_session} not found")

    # Check if agent_sessions already exist
    if parent_session.agent_sessions and len(parent_session.agent_sessions) > 0:
        raise Exception(
            "Agent sessions already exist for this session. "
            "start_session should only be called once."
        )

    # Parse args
    shared_understanding = context.args.get("shared_understanding", "")
    agent_contexts_raw = context.args.get("agent_contexts", [])
    finish_criteria = context.args.get("finish_criteria", "")

    if not shared_understanding:
        raise Exception("shared_understanding is required")
    if not agent_contexts_raw:
        raise Exception("agent_contexts is required")
    if not finish_criteria:
        raise Exception("finish_criteria is required")

    # Parse agent_contexts
    agent_contexts = []
    for ac in agent_contexts_raw:
        if isinstance(ac, dict):
            agent_contexts.append(
                AgentContext(
                    agent_username=ac.get("agent_username", ""),
                    context=ac.get("context", ""),
                )
            )
        elif isinstance(ac, AgentContext):
            agent_contexts.append(ac)

    if not agent_contexts:
        raise Exception("At least one agent_context is required")

    # Build the init response object
    init_response = ModeratorInitResponse(
        shared_understanding=shared_understanding,
        agent_contexts=agent_contexts,
        finish_criteria=finish_criteria,
    )

    logger.info(
        f"[MODERATOR_START] Initializing session {parent_session.id} "
        f"with {len(agent_contexts)} agent contexts"
    )

    # Create agent sessions using existing function
    from eve.agent.session.setup import create_agent_sessions_with_contexts

    agent_sessions = create_agent_sessions_with_contexts(
        parent_session=parent_session,
        agents=parent_session.agents,
        init_response=init_response,
    )

    # Update parent session with agent_sessions map
    parent_session.update(agent_sessions=agent_sessions)

    logger.info(
        f"[MODERATOR_START] Created {len(agent_sessions)} agent sessions: "
        f"{list(agent_sessions.keys())}"
    )

    # Create MODERATOR_START eden message in parent session
    eden_content = init_response.model_dump_json()
    eden_message = ChatMessage(
        session=[parent_session.id],
        sender=ObjectId("000000000000000000000000"),  # System sender
        role="eden",
        content=eden_content,
        eden_message_data=EdenMessageData(message_type=EdenMessageType.MODERATOR_START),
    )
    eden_message.save()

    logger.info(
        f"[MODERATOR_START] Created MODERATOR_START eden message {eden_message.id}"
    )

    # Build response with agent usernames
    created_agents = []
    for agent_id_str in agent_sessions.keys():
        agent = Agent.from_mongo(ObjectId(agent_id_str))
        if agent:
            created_agents.append(agent.username)

    return {
        "output": {
            "status": "success",
            "message": f"Session initialized with {len(agent_sessions)} agent workspaces",
            "agents": created_agents,
            "finish_criteria": finish_criteria,
        }
    }
